#ifndef DEMOGRAPHER_H
#define DEMOGRAPHER_H

#include <stdint.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include <list>
#include <DynamicQueue.H>
#include <Message.H>
#include <Person.H>
#include "adevs.h"

// Implements a module simulating partnership sexual debut, aging and
// background (non-HIV) mortality. This module is also responsible for
// introducing the initial cases of HIV infection into the population.
//
// Listens for DEATH_HIV events. The module deschedules aging and
// background mortality for individuals who die from HIV.
//
// Emits DEBUT, AGE and DEATH_NAT events. Additionally, emits INFECT
// events when seed cases are introduced. Unlike INFECT events
// generated by the Transmission module, INFECT events for seed cases
// have a NULL infection donor.
class Demographer : public adevs::Atomic<Message> {
public:
  Demographer();
  virtual ~Demographer();

  // Container must store pointers of type Person*. People added to
  // the population this way will have a DEBUT event inserted into
  // their history, and the Demographer will assign them a time of
  // natural death.
  template<typename Container>
  void initialize(Container const& people, unsigned long int seed) {
    m_rng = gsl_rng_alloc(gsl_rng_mt19937);
    gsl_rng_set(m_rng, seed);

    // schedule events for the initial population
    typename Container::const_iterator pi;
    for (pi = people.begin(); pi != people.end(); ++pi) insert(*pi, true);

    m_time[DEBUT_INT] = m_tcurr + wait_debut();
    m_time[ENTER_INT] = m_tcurr + params.year_init;
    update_schedule();
  }

  // adevs::Atomic<T> interface
  virtual double ta() {return m_time[m_next] - m_tcurr;}
  virtual void delta_int();
  virtual void delta_ext(double dt, adevs::Bag<Message> const& msgs);
  virtual void delta_conf(adevs::Bag<Message> const& msgs);
  virtual void output_func(adevs::Bag<Message>& msgs);
  virtual void gc_output(adevs::Bag<Message>& garbage) {}

private:
  // The demography module manages three internal events. These are
  // named using the *_INT convention to distinguish them from global
  // events defined in ModelTypes.H
  //
  // DEBUT_INT - sexual debut
  // AGING_INT - transition between age bands
  // DEATH_INT - HIV-unrelated mortality
  // ENTER_INT - immigration into the sexually active population. Used to seed the epidemic
  enum Event {DEBUT_INT=0, AGING_INT=1, DEATH_INT=2, ENTER_INT=3, EVENTS_INT=4};

  // Data structure used to schedule internal events
  struct Record {
    Record(double t = infinity, Event e = EVENTS_INT) : time(t), event(e) {}
    bool operator<(Record const& record) const {return time > record.time;}
    double time;
    Event event;
  };

  typedef DynamicQueue<Person*, Record> Queue;

  // Determine the next event (aging or death) experienced by Person
  // p. Some events may be scheduled differently depending on whether
  // next_event is called as part of module initialization versus
  // module simulation. The 'initialize' flag is true for the former
  // and false for the latter
  Record next_event(Person* p, bool const initialize = false);

  // helper function that updates scheduling variables
  void update_schedule();

  // Helper functions that insert or remove people from tracking. The
  // initialize argument to insert is used to distinguish individuals
  // inserted at module initialization from those inserted during
  // model execution (the former may have arbitrary age, while the
  // latter enter the model at sexual debut; the code to handle the
  // former is more complicated, so we bypass it whenever possible).
  void insert(Person* p, bool const initialize = false);
  void remove(Person* p);

  // internal event handlers
  void debut_int();
  void aging_int();
  void death_int();
  void enter_int();

  // external event handlers
  void death_ext(Person* person);

  void debut_out(adevs::Bag<Message>& msgs);
  void aging_out(adevs::Bag<Message>& msgs);
  void death_out(adevs::Bag<Message>& msgs);
  void enter_out(adevs::Bag<Message>& msgs);

  // Draws a wait time between consecutive debut events. Since
  // fertility decreases with time, sexual debut is a non-homogeneous
  // Poisson process
  //
  // We may be able to safely approximate the debut rate by accepting
  // the first wait time produced. This approximation seems
  // appropriate because the rejection rate vanishes as the population
  // size grows large. Even in a small population of 2,050 people, 30
  // independent 52-year simulations produced only 19 rejections
  // total. This approximation would improve simulation speeds by
  // eliminating some logic and reducing the number of random draws.
  inline double wait_debut() {
    // gp: growth parameters, fitted to match Statistics South Africa 2013
    // mid-year population estimates for population size and age
    // distribution using the ODE model (see 2013-11-20 report).
    const double gp[] = {
      2.0 * params.rate_grow_init - params.rate_grow_late,
      params.rate_grow_late, params.rate_grow_decr, 0};
    const double ncurr(population_size());
    const double rcurr((gp[0] + (gp[1] - gp[0]) / (1.0 + exp(-gp[2] * (m_tcurr - gp[3])))) * ncurr);

    //#warning "locally homogeneous debut approximation"
    //    return(gsl_ran_exponential(m_rng, 1.0 / rcurr));

    // use thinning to sample a waiting time from the debut process
    double rnext(rcurr), twait(0.0), u;
    do {
      u = gsl_rng_uniform(m_rng);
      twait += gsl_ran_exponential(m_rng, 1.0 / rnext);
      rnext = ncurr * (gp[0] + (gp[1] - gp[0]) / (1.0 + exp(-gp[2] * (m_tcurr + twait - gp[3]))));
    } while(rcurr * u > rnext);
    return twait;
  }

  // draws a wait time from model entry until death
  inline double wait_death(Person const* person) {
    return gsl_ran_exponential(m_rng, params.wait_death[person->sex()][person->age_band()]);
  }

  // return the number of people in the living population
  inline uint32_t population_size() const {return m_queue.size();}

  gsl_rng* m_rng;

  // Demographer clock
  double m_tcurr;

  // Cache for times of scheduled events. The internal event queue
  // (m_queue) is used to store death and aging events. Instead of
  // populating m_time from the queue with the earliest death and
  // aging events, we may set m_time = infinity for the later of these
  // two events. Bottom line: the earliest event time is trustworthy,
  // later events may be imprecise.
  //
  // storage is allocated for m_time[EVENTS_INT] to ensure that the
  // queue sentinel record is handled correctly in cohort simulations
  double m_time[EVENTS_INT+1];

  // stores the next event's type
  Event m_next;

  // Used to cache the next person to enter the population
  Person* m_debut;

  // Used to cache seed cases of HIV
  std::list<Person*> m_enter;

  // Queue used to schedule internal events
  Queue m_queue;
};

#endif // DEMOGRAPHER_H
